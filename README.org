* About

PureLisp is a programming language that runs on any WebAssembly-enabled platform that's meant for writing platform-independent tools, which can be used on any platform.

It is a 100% functional programming language and as such it has no mutable data and no side effects.

Before you start to wonder whether this is April fools' joke, let me explain: you don't need any side effects in PureLisp, because the host platform can provide them.

* Why?

Domain specific languages are seriously underrated. If someone wants to design a programming language, they nearly always go for a generic purpose programming language.

It seems to make sense, after all why shouldn't you be able to write anything in such language.

But the reality is more intricate than that and specialisation in many cases does pay off.

Take Elm for instance: it made its trade-offs and because of them it's an absolutely amazing language for writing web apps.

And this is what PureLisp is trying to accomplish for multi-platform data libraries.

* Multiplatform code

Back in the days you could write an app in C and make it run on any platform. It would have a lot of platform specific code (especially for implementing the GUI), but it was totally possible.

Then the mobile platform came and suddenly you can only write in Swift or Objective C for iOS, ......... how is it on Android? Is Kotlin enforced or can you use any language? After all, it's Linux.

This complicates everything and makes development more expensive.

So someone comes and says "F-it! Let's write in HTML/CSS/JS and let's just have a WebView wrappers for them."

And it works. You have your hybrid app and it runs on Windows, macOS, Linux, it runs on iOS and it runs on Android.

But something's off. It just doesn't look right. It doesn't behave right either. And it's missing the wow factor of a good iOS app. Not mention that it's not the fastest thing in the universe either.

Having to write native UI for each platform is just the way it is if you want your app to be any good. There are some exceptions that managed to get away with the hybrid approach, but they are few and far between.

So then? Do we have to always port /everything/ to every supported platform?

Well, no!

Write the platform-specific UI in whatever language is required by the platform, but write the logic in something that runs anywhere.

Enter PureLisp.

* Features

** Write once, run anywhere

What Java didn't manage to deliver, WebAssembly did. And since PureLisp is written for the WebAssembly platform, you get all the benefits.

Namely you can run PureLisp in a browser, within an iOS/iPadOS app and on the server by embedding it into runtime of your choice (Rust, Node.js, Ruby, you name it).

** 100% secure

Since WebAssembly runtime is a container[1] and there are no OS bindings, there is no way to access the file system from PureLisp (there is from the host language of course) and there is no way to run external commands or execute OS syscalls.

[1] It's not, but I can't remember the right word now.
[2] How about network? Should we allow fetch()? Does WASM support that at all? We would have to implement exceptions though :/

** Functional programming

** Virtual FS

Since there are no side effects, reading or writing files is not possible in PureLisp.

Fortunately there's a simple workaround, that's totally FP-friendly.

#+BEGIN_SRC javascript
function main() {
  const blogPostSources = VirtualFS.read('~/blog')
  const blogPostOutput = VirtualFS.open('output')
  const updatedVirtualFS = pureLispRuntime.generate(blogPostSources, blogPostOutput)
  updatedVirtualFS.commit()
}
#+END_SRC

If no I/O actions are required, VFS can be created from within PureLisp:

#+BEGIN_SRC lisp
(expose (function generate-from-scratch (sources-vfs) (
  (mkvfs (
    (map (glob sources-vfs "*.org")
         lambda (stream) (generate-blog-post stream)))))))
#+END_SRC

#+BEGIN_SRC javascript
function main() {
  const blogPostSources = VirtualFS.read('~/blog')
  const outputVFS = pureLispRuntime.generate(blogPostSources, blogPostOutput)
  outputVFS.commit('output')
}
#+END_SRC

** Macros and reader macros

* Design decisions

** Embedded programming language

/PureLisp is not a generic programming language./

This is the most important thing to keep in mind.

There are bunch of things it doesn't do:

- It can't run external commands.
- It has no bindings to low-level